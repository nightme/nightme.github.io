<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nightme.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="事件循环Event Loop 是一种运行机制。 宏任务macrotask和微任务microtask两个概念，这表示任务的两种分类。 在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行； 之后再取 macrotask 任务，周而复始，直">
<meta property="og:type" content="article">
<meta property="og:title" content="事件循环">
<meta property="og:url" content="https://nightme.github.io/2018/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/index.html">
<meta property="og:site_name" content="某人">
<meta property="og:description" content="事件循环Event Loop 是一种运行机制。 宏任务macrotask和微任务microtask两个概念，这表示任务的两种分类。 在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行； 之后再取 macrotask 任务，周而复始，直">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281133.png">
<meta property="og:image" content="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281418.gif">
<meta property="og:image" content="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281054.png">
<meta property="article:published_time" content="2018-10-07T05:07:35.000Z">
<meta property="article:modified_time" content="2025-09-19T04:25:12.110Z">
<meta property="article:author" content="某人">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281133.png">

<link rel="canonical" href="https://nightme.github.io/2018/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>事件循环 | 某人</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">某人</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">此前素未谋面、此后遥遥无期</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nightme.github.io/2018/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="某人">
      <meta itemprop="description" content="此前素未谋面、此后遥遥无期">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="某人">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          事件循环
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-07 13:07:35" itemprop="dateCreated datePublished" datetime="2018-10-07T13:07:35+08:00">2018-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-19 12:25:12" itemprop="dateModified" datetime="2025-09-19T12:25:12+08:00">2025-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><code>Event Loop</code> 是一种运行机制。</p>
<p>宏任务<code>macrotask</code>和微任务<code>microtask</code>两个概念，这表示任务的两种分类。</p>
<p>在挂起任务时，<code>JS</code> 引擎会将所有任务按照类别分到这两个队列中，首先在 <code>macrotask</code> 的队列（这个队列也被叫做 <code>task queue</code>）中取出第一个任务，执行完毕后取出 <code>microtask</code> 队列中的所有任务顺序执行；</p>
<p>之后再取 <code>macrotask</code> 任务，周而复始，直至两个队列的任务都取完。</p>
<span id="more"></span>

<h3 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a><code>V8</code>引擎</h3><p><code>V8</code>引擎基本概念关系图 (根据 <code>Google V8</code> 官方文档)</p>
<p><a target="_blank" rel="noopener" href="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281123.jpg">http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281123.jpg</a></p>
<h4 id="handle"><a href="#handle" class="headerlink" title="handle"></a><code>handle</code></h4><p><code>handle </code>是指向对象的指针，在 <code>V8</code> 中，所有的对象都通过 <code>handle</code> 来引用，<code>handle</code> 主要用于 <code>V8</code>的垃圾回收机制。</p>
<h4 id="上下文-context"><a href="#上下文-context" class="headerlink" title="上下文(context)"></a>上下文(<code>context</code>)</h4><p><code>context</code> 是一个执行器环境，使用 <code>context</code> 可以将相互分离的 <code>JavaScript</code> 脚本在同一个 <code>V8</code> 实例中运行，而互不干涉。在运行 <code>JavaScript</code> 脚本是，需要显式的指定 <code>context</code> 对象。</p>
<h3 id="运行时概念"><a href="#运行时概念" class="headerlink" title="运行时概念"></a>运行时概念</h3><h4 id="可视化描述"><a href="#可视化描述" class="headerlink" title="可视化描述"></a>可视化描述</h4><p><img src="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281133.png" alt="image"></p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>函数调用形成了一个栈帧。</p>
<p><img src="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281418.gif" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b + <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo</span>(x * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>

<p>当调用<code>bar</code>时，创建了第一个帧 ，帧中包含了<code>bar</code>的参数和局部变量。</p>
<p>当<code>bar</code>调用<code>foo</code>时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了<code>foo</code>的参数和局部变量。当<code>foo</code>返回时，最上层的帧就被弹出栈（剩下<code>bar</code>函数的调用帧 ）。</p>
<p>当<code>bar</code>返回的时候，栈就空了。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>一个 <code>JavaScript</code> 运行时包含了一个待处理的消息队列。每一个消息都有一个为了处理这个消息相关联的函数。</p>
<p>在事件循环期间的某个时刻，运行时总是从最先进入队列的一个消息开始处理队列中的消息。正因如此，这个消息就会被移出队列，并将其作为输入参数调用与之关联的函数。为了使用这个函数，调用一个函数总是会为其创造一个新的栈帧，一如既往。</p>
<p>函数的处理会一直进行直到执行栈再次为空；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>
<h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h2><h3 id="事件循环-WHATWG规范"><a href="#事件循环-WHATWG规范" class="headerlink" title="事件循环(WHATWG规范)"></a>事件循环(WHATWG规范)</h3><p>要协调事件<code>(event)</code>，用户交互<code>(user interaction)</code>，脚本<code>(script)</code>，渲染<code>(rendering)</code>，网络<code>(networking)</code>等，用户代理<code>(user agent)</code>就需要使用事件循环<code>(event loops)</code>。</p>
<p>有两种事件循环：</p>
<ol>
<li>用于浏览器上下(<code>browsing context</code>)文的事件循环</li>
<li>用于<code>workers</code>的事件循环</li>
</ol>
<h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><ul>
<li><p>一个事件循环有一个或多个任务队列(<code>task queues</code>),一个任务队列是有序列表的任务,这些算法负责以下工作：<br>事件(<code>Events</code>)，解析(<code>Parsing</code>) ，回调(<code>Callbacks</code>)，使用资源(<code>Using a resource</code>)，对DOM操作做出反应(<code>Reacting to DOM manipulation</code>)</p>
</li>
<li><p>每个任务都定义为来自特定任务源<code>task source</code>。必须始终添加来自一个特定任务源并发往特定事件循环的所有任务(例如，由<code>Document</code>的计时器生成的回调，针对该<code>Document</code>的鼠标移动而触发的事件，排队等待该<code>Document</code>的解析器的任务)到同一任务队列，但来自不同任务源的任务可以放在不同的任务队列中。</p>
</li>
<li><p>例如，用户代理可以为鼠标和键事件(用户交互任务源)创建一个任务队列，为其他所有事件设置另一个任务队列。然后，用户代理可以在四分之三的时间内为其他任务提供键盘和鼠标事件首选项，保持界面响应但不会使其他任务队列处于饥饿状态，并且永远不会无序地处理来自任何一个任务源的事件。</p>
</li>
<li><p>每个事件循环都有一个当前运行的任务。最初，这是null。它用于处理重入。每个事件循环还具有执行微任务检查点标志(<code>microtask checkpoint flag</code>)，该标志最初必须为假(<code>false</code>)。它用于防止执行微任务检查点算法的重入调用。</p>
</li>
</ul>
<h3 id="事件循环处理模型"><a href="#事件循环处理模型" class="headerlink" title="事件循环处理模型"></a>事件循环处理模型</h3><p>一个事件循环存在，将连续执行以下步骤：</p>
<ol>
<li>选择最先进入事件循环任务队列的一个任务(<code>oldestTask</code>)， 如果队列中没有任务，则直接跳到第6步的<code>microtask</code></li>
<li>将事件循环的当前运行任务设置为上一步所选择的任务(<code>oldestTask</code>)</li>
<li>运行所选任务(<code>oldestTask</code>)</li>
<li>将事件循环的当前运行任务设置为<code>null</code> 。</li>
<li>从其任务队列中移除<code>oldestTask</code>。</li>
<li>微任务(<code>microtask</code>):执行微任务检查点</li>
<li>更新渲染(<code>update the rendering</code>)</li>
<li>如果这是一个<code>worker</code>事件循环（即一个为<code>WorkerGlobalScope</code>运行的循环）</li>
<li>跳到第一步</li>
</ol>
<h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(<code>microtask</code>)</h3><p>每个事件循环都有一个微任务队列。微任务是最初要在微任务队列上排队的任务，而不是任务队列上排队的任务</p>
<p>当算法需要对微任务进行排队时，必须将其附加到相关事件循环的微任务队列中;这种微任务的任务源是微任务任务源</p>
<p>当用户代理要 <strong>执行微任务检查点</strong> 时，如果执行微任务检查点标志为<code>false</code>，则用户代理必须运行以下步骤：</p>
<ol>
<li>将执行微任务检查点标志(<code>flag</code>)设置为<code>true</code>。</li>
<li>而事件循环的微任务队列不为空:<ol>
<li>让<code>oldestMicrotask</code>成为事件循环的微任务队列中最老的微任务(<code>oldest microtask </code>)</li>
<li>将事件循环的当前运行任务设置为<code>oldestMicrotask</code></li>
<li>运行<code>oldestMicrotask</code></li>
<li>将事件循环的当前运行任务设置为<code>null</code>。</li>
<li>从微任务队列中删除<code>oldestMicrotask</code>。</li>
</ol>
</li>
<li>对于其负责事件循环是此事件循环的每个环境设置对象，请通知该环境设置对象上被拒绝的承诺。</li>
<li>清理索引数据库事务。</li>
<li>将执行微任务检查点标志设置为<code>false</code>。</li>
</ol>
<p>微任务的实现：</p>
<ul>
<li><code>process.nextTick</code>:事件循环的下一次循环中调用 <code>callback</code> 回调函数</li>
<li><code>Promises</code>:<code>Promise</code> 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。</li>
<li><code>Object.observe</code>:<code>Object.observe()</code> 方法用于异步地监视一个对象的修改</li>
<li><code>MutationObserver</code>:(<code>Mutation Observer API</code> 用来监视 <code>DOM</code> 变动)</li>
</ul>
<h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(<code>macrotask</code>)</h3><p>宏任务的实现：</p>
<ol>
<li><code>script</code>（整体代码）</li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code>:该方法用来把一些需要长时间运行的操作放在一个回调函数里,在浏览器完成后面的其他语句后,就立刻执行这个回调函数,</li>
<li><code>I/O</code></li>
<li><code>UI rendering</code></li>
</ol>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>chrome</code>执行顺序：</p>
<p><code>script start</code>、<code>script end</code>、<code>promise1</code>、<code>promise2</code>、<code>setTimeout</code></p>
<h2 id="nodejs事件循环"><a href="#nodejs事件循环" class="headerlink" title="nodejs事件循环"></a>nodejs事件循环</h2><p><code>nodejs</code>的<code>event</code>是基于<code>libuv</code></p>
<p>事件循环允许<code>Node.js</code>执行非阻塞<code>I/O</code>操作</p>
<p>尽管<code>JavaScript</code>是单线程的,通过尽可能将操作卸载到系统内核。</p>
<p>由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。 当其中一个操作完成时，内核会告诉<code>Node.js</code>，以便可以将相应的回调添加到轮询队列中以最终执行。</p>
<h3 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h3><p>当<code>Node.js</code>启动时，它初始化事件循环，处理提供的输入脚本（或放入交互式解释器(<code>REPL</code>)），这可能会进行异步<code>API</code>调用，调度计时器或调用<code>process.nextTick</code>， 然后开始处理事件循环。</p>
<h3 id="事件循环操作顺序"><a href="#事件循环操作顺序" class="headerlink" title="事件循环操作顺序:"></a>事件循环操作顺序:</h3><p><strong>注意：</strong> 以下每个框都将被称为事件循环的“阶段”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>每个阶段都有一个要执行的回调先入先出(<code>First Input First Output</code>)队列。虽然每个阶段都有自己的特殊之处，但通常，当事件循环进入给定阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或执行的回调的最大数量为止。当队列耗尽或达到回调限制时，事件循环将移至下一阶段，依此类推。</p>
<p>由于这些操作中的任何一个可以调度更多操作,并且在轮询阶段中处理的新事件由内核排队，因此轮询事件可以在处理轮询事件时排队。因此，长时间运行的回调可以允许轮询阶段运行的时间比计时器的阈值长得多</p>
<p><strong>注意</strong>：<code>Windows</code>和<code>Unix/Linux</code>实现之间存在轻微差异，但这对于此演示并不重要。最重要的部分在这里。实际上有七到八个步骤，而我们关心的是 - <code>Node.js</code>实际使用的那些 - 是上面那些。</p>
<h3 id="阶段概述"><a href="#阶段概述" class="headerlink" title="阶段概述"></a>阶段概述</h3><p><code>nodejs</code>的事件循环分为6个阶段</p>
<ol>
<li>计时器(<code>timers</code>):此阶段执行<code>setTimeout()</code>和<code>setInterval()</code>调度的回调。</li>
<li>等待回调(<code>pending callbacks</code>):执行延迟到下一个循环迭代的<code>I/O</code>回调</li>
<li>空闲,准备(<code>idle, prepare</code>):仅在内部使用</li>
<li>轮询(<code>poll</code>):检索新的<code>I/O</code>事件;执行与<code>I/O</code>相关的回调（几乎所有回调都是关闭回调，定时器和<code>setImmediate()</code>调度的回调）;<code>node</code>将在适当的时候阻止</li>
<li><code>check</code>:<code>setImmediate()</code>在这里调用回调</li>
<li>关闭回调(<code>close callbacks</code>):一些关闭回调,例如<code>socket.on</code>（’close’，…）</li>
</ol>
<p>在事件循环的每次运行之间，<code>Node.js</code>检查它是否在等待任何异步的<code>I/O</code>或定时器，如果没有，则关闭。</p>
<p>代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate&quot;</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;process.nextTick&quot;</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise&quot;</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">;(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>))()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ node index.<span class="property">js</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">process.<span class="property">nextTick</span> <span class="number">3</span></span><br><span class="line"><span class="title class_">Promise</span> <span class="number">4</span></span><br><span class="line"><span class="built_in">setTimeout</span> <span class="number">1</span></span><br><span class="line">setImmediate <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="循环阶段详情"><a href="#循环阶段详情" class="headerlink" title="循环阶段详情"></a>循环阶段详情</h3><h4 id="计时器-timers"><a href="#计时器-timers" class="headerlink" title="计时器(timers)"></a>计时器(<code>timers</code>)</h4><p>计时器指定阈值，在该阈值之后可以执行提供的回调而不是人们希望它执行的确切时间。 定时器回调将在指定的时间过去后尽早安排; 但是，操作系统调度或其他回调的运行可能会延迟它们。</p>
<p>注意：从技术上讲，轮询阶段控制何时执行定时器。</p>
<p>例如，假设您计划在<code>100</code>毫秒阈值后执行超时，那么您的脚本将异步读取一个耗时<code>95</code>毫秒的文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些异步操作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncOperation</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">//假设这需要95ms才能完成</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;d:/all.txt&#x27;</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> delay = <span class="title class_">Date</span>.<span class="title function_">now</span>() - timeoutScheduled;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`已经过去了<span class="subst">$&#123;delay&#125;</span>ms`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些需要95毫秒完成的异步操作</span></span><br><span class="line"><span class="title function_">someAsyncOperation</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> startCallback = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;while开始&quot;</span>);</span><br><span class="line">    <span class="comment">//做一些需要10ms的事情....</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;while结束&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当事件循环进入轮询阶段时，它有一个空队列（<code>fs.readFile（）</code>尚未完成），因此它将等待<code>剩余的ms</code>数，直到达到最快的计时器阈值。 当它等待<code>95</code>毫秒传递时，<code>fs.readFile（）</code>完成读取文件，并且其完成需要<code>10</code>毫秒的回调被添加到轮询队列并执行。 当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的阈值，然后回绕到定时器阶段以执行定时器的回调。 在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为<code>105</code>毫秒。</p>
<p>注意：为了防止轮询阶段使事件循环挨饿，<code>libuv</code>(实现<code>Node.js</code>事件循环的<code>C</code>库和平台的所有异步行为）在停止轮询更多的事件之前具有硬性最大值（取决于系统）。</p>
<h4 id="等待回调-pending-callbacks"><a href="#等待回调-pending-callbacks" class="headerlink" title="等待回调(pending callbacks)"></a>等待回调(<code>pending callbacks</code>)</h4><p>此阶段执行某些系统操作（例如<code>TCP</code>错误类型）的回调。 例如，如果<code>TCP</code>套接字在尝试连接时收到拒绝<code>ECONNREFUSED</code>，则某些<code>*nix</code>系统希望等待报告错误。 这将排队等待在挂起的回调阶段执行。</p>
<h4 id="轮询-poll"><a href="#轮询-poll" class="headerlink" title="轮询(poll)"></a>轮询(<code>poll</code>)</h4><p>轮询阶段有两个主要功能:</p>
<ol>
<li>计算它应该阻止和轮询<code>I/O</code>的时间,然后</li>
<li>处理轮询队列中的事件。</li>
</ol>
<p>当事件循环进入轮询阶段并且没有计划定时器时，将发生以下两种情况之一:</p>
<ol>
<li>如果轮询队列不为空，则事件循环将遍历其同步执行它们的回调队列，直到队列已用尽或者达到系统相关的硬性限制。</li>
<li>如果轮询队列为空，则会发生以下两种情况之一：<ul>
<li>如果<code>setImmediate()</code>已调度脚本，则事件循环将结束轮询阶段并继续执行检查阶段以执行这些调度脚本。</li>
<li>如果<code>setImmediate()</code>尚未调度脚本，则事件循环将等待将回调添加到队列，然后立即执行它们。</li>
</ul>
</li>
</ol>
<p>轮询队列为空后，事件循环将检查已达到时间阈值的计时器。 如果一个或多个计时器准备就绪，事件循环将回绕到计时器阶段以执行那些计时器的回调。</p>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a><code>check</code></h4><p>此阶段允许人员在轮询阶段完成后立即执行回调。 如果轮询阶段变为空闲并且脚本已使用<code>setImmediate()</code>排队，则事件循环可以继续到检查阶段而不是等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。 它使用<code>libuv API</code>来调度,在轮询阶段完成后执行的回调。</p>
<p>通常，在执行代码时，事件循环最终会到达轮询阶段，它将等待传入连接，请求等。但是，如果已使用<code>setImmediate()</code>调度回调并且轮询阶段变为空闲，则将结束并继续检查阶段，而不是等待轮询事件。</p>
<h4 id="关闭回调close-callbacks"><a href="#关闭回调close-callbacks" class="headerlink" title="关闭回调close callbacks"></a>关闭回调<code>close callbacks</code></h4><p>如果套接字或句柄突然关闭（例如<code>socket.destroy()</code>），则在此阶段将发出<code>close</code>事件。 否则它将通过<code>process.nextTick()</code>发出。</p>
<h3 id="setImmediate-与-setTimeout"><a href="#setImmediate-与-setTimeout" class="headerlink" title="setImmediate() 与 setTimeout()"></a><code>setImmediate()</code> 与 <code>setTimeout()</code></h3><p><code>setImmediate</code>和<code>setTimeout()</code>类似，但根据它们的调用时间以不同的方式运行。</p>
<ol>
<li><code>setImmediate()</code>用于在当前轮询阶段完成后执行脚本,即check阶段。</li>
<li><code>setTimeout()</code>计划在经过最小阈值（以<code>ms</code>为单位）后运行的脚本。</li>
</ol>
<p>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，则时间将受到进程性能的限制（可能受到计算机上运行的其他应用程序的影响）。</p>
<p>例如，如果我们运行不在<code>I/O</code>周期内的以下脚本（即主模块），则执行两个定时器的顺序是不确定的，因为它受进程性能的约束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout_vs_immediate.js</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">immediate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出的顺序不确定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line"><span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

<p>但是，如果在<code>I/O</code>周期内移动两个调用，则始终首先执行立即回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;d:/all.txt&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>始终首先执行立即回调<code>immediate</code>,再执行<code>setTimeout</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line"><span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

<p>使用<code>setImmediate()</code>而不是<code>setTimeout()</code>的主要优点是<code>setImmediate()</code>将始终在任何定时器之前执行（如果在<code>I/O</code>周期内调度），与存在多少定时器无关。</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h3><h4 id="了解process-nextTick"><a href="#了解process-nextTick" class="headerlink" title="了解process.nextTick()"></a>了解<code>process.nextTick()</code></h4><p>您可能已经注意到<code>process.nextTick()</code>没有显示在图中，即使它是异步API的一部分。 这是因为<code>process.nextTick</code>在技术上不是事件循环的一部分。 相反，<code>nextTickQueue</code>将在当前操作完成后处理，而不管事件循环的当前阶段如何。</p>
<p>回顾一下上面的图表，无论何时在给定阶段调用<code>process.nextTick()</code>，传递给<code>process.nextTick()</code>的所有回调都将在事件循环继续之前得到解决。 这可能会产生一些不好的情况，因为它允许您通过进行递归的<code>process.nextTick()</code>调用来饿死(<code>starve</code>)您的<code>I/O</code>，这会阻止事件循环到达轮询阶段。</p>
<h4 id="为什么会被允许"><a href="#为什么会被允许" class="headerlink" title="为什么会被允许"></a>为什么会被允许</h4><p>为什么这样的东西会被包含在<code>Node.js</code>中? 其中一部分是一种设计理念，其中<code>API</code>应该始终是异步的，即使它不是必须的。 以下面代码段为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">apiCall</span>(<span class="params">arg, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(callback,<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;参数应该是字符串&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码片段进行参数检查，如果不正确，它会将错误传递给回调。这个API最近更新了，允许将参数传递给<code>process.nextTick()</code>，允许它将回调后传递的任何参数作为参数传播到回调，因此您不必嵌套函数。</p>
<p>我们正在做的是将错误传回给用户，但只有在我们允许其余的用户代码执行之后。 通过使用<code>process.nextTick</code>，我们保证<code>apiCall()</code>始终在用户代码的其余部分之后和允许事件循环继续之前运行其回调。 为了实现这一点，允许<code>JS</code>调用堆栈展开然后立即执行提供的回调，这允许一个人对<code>process.nextTick()</code>进行递归调用而不会达到<code>RangeError</code>：超出<code>v8</code>的最大调用堆栈大小。</p>
<p>这种理念可能会导致一些潜在的问题,以以下片段为例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这有一个异步签名，但同步调用回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncApiCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在`someAsyncApiCall`完成之前调用回调。</span></span><br><span class="line"><span class="title function_">someAsyncApiCall</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于someAsyncApiCall已完成，因此bar未分配任何值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>, bar); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>用户将<code>someAsyncApiCall()</code>定义为具有异步签名，但它实际上是同步操作的。 调用它时，在事件循环的同一阶段调用提供给<code>someAsyncApiCall()</code>的回调，因为<code>someAsyncApiCall()</code>实际上不会异步执行任何操作。 因此,回调尝试引用<code>bar</code>，即使它在范围内可能没有该变量，因为该脚本无法运行完成。</p>
<p>通过将回调放在<code>process.nextTick()</code>中，脚本仍然能够运行完成，允许在调用回调之前初始化所有变量，函数等。 它还具有不允许事件循环继续的优点。 在允许事件循环继续之前，向用户警告错误可能是有用的。</p>
<p>以下是使用<code>process.nextTick()</code>的前一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncApiCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    process.<span class="title function_">nextTick</span>(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncApiCall</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这是另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> server = net.<span class="title function_">createServer</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(server.<span class="title function_">address</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>仅传递端口时，端口立即绑定。 因此可以立即调用<code>listen</code>回调。 问题是那时候不会设置<code>.on（&#39;listen&#39;）</code>。</p>
<p>为了解决这个问题，<code>listening</code>事件在<code>nextTick</code>中排队，以允许脚本运行完成。 这允许用户设置他们想要的任何事件处理程序。</p>
<h3 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a><code>process.nextTick()</code> vs <code>setImmediate()</code></h3><p>就用户而言，我们有两个类似的调用，但它们的名称令人困惑。</p>
<ul>
<li><code>process.nextTick()</code>在同一阶段立即触发</li>
<li><code>setImmediate()</code>触发事件循环的后续迭代或<code>tick</code></li>
</ul>
<p>本质上，这些名字应该被交换。与<code>setimmediation()</code>相比，<code>process.nextTick()</code>更快速地触发，但这是过去的产物，不太可能改变。这样做会破坏npm上的大部分包。每天都有更多的新模块被添加，这意味着我们每天都在等待，更多的潜在故障发生。虽然它们令人困惑，但名称本身不会改变。</p>
<p>建议开发人员在所有情况下都使用<code>setimmediation()</code>，因为这样做更容易理解(而且会导致代码与更广泛的环境兼容，比如浏览器<code>JS</code>)。</p>
<h3 id="为什么使用process-nextTick"><a href="#为什么使用process-nextTick" class="headerlink" title="为什么使用process.nextTick()"></a>为什么使用<code>process.nextTick()</code></h3><p>主要有两个原因：</p>
<ol>
<li>允许用户处理错误，清除任何不需要的资源，或者在事件循环继续之前再次尝试请求。</li>
<li>有时需要允许回调在调用堆栈展开之后但在事件循环继续之前运行。</li>
</ol>
<p>一个例子简单的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> server = net.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span>(<span class="params">conn</span>) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(server.<span class="title function_">address</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>假设<code>listen()</code>在事件循环的开头运行，但是侦听回调被放置在<code>setimmediation()</code>中。现在，除非将主机名传递给端口，否则绑定将立即发生。现在，为了让事件循环继续进行，它必须到达轮询阶段，这意味着有一个非零的机会，连接可能已经收到，允许连接事件在侦听事件之前被触发。</p>
<p>另一个例子是运行一个函数构造函数，比如继承自<code>EventEmitter</code>，它想在构造函数中调用一个事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyEmitter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">EventEmitter</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.<span class="title function_">inherits</span>(<span class="title class_">MyEmitter</span>, <span class="title class_">EventEmitter</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了一件事！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>您无法立即从构造函数中发出事件，因为脚本将不会处理到用户为该事件分配回调的位置。 因此，在构造函数本身中，您可以使用<code>process.nextTick()</code>来设置回调以在构造函数完成后发出事件，从而提供预期的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyEmitter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">EventEmitter</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配处理程序后，使用nextTick发出事件</span></span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>);</span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">util.<span class="title function_">inherits</span>(<span class="title class_">MyEmitter</span>, <span class="title class_">EventEmitter</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了一件事！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h2><p><code>libuv</code>是最初为<code>NodeJS</code>编写的跨平台支持库。 它是围绕事件驱动的异步<code>I/O</code>模型设计的。</p>
<h3 id="I-x2F-O-或事件-循环"><a href="#I-x2F-O-或事件-循环" class="headerlink" title="I&#x2F;O(或事件)循环"></a>I&#x2F;O(或事件)循环</h3><p><code>I/O</code>(或事件)循环是<code>libuv</code>的中心部分。它为所有<code>I/O</code>操作建立内容，并且它被绑定到一个线程。只要在不同的线程中运行，就可以运行多个事件循环。<code>libuv</code>事件循环(或任何其他涉及循环或句柄的<code>API</code>)不是线程安全的，除非另有说明。</p>
<p>为了更好地理解事件循环的运行方式，下图说明了循环迭代的所有阶段：</p>
<p><img src="http://imagesrc.oss-cn-shenzhen.aliyuncs.com/notes/201809281054.png" alt="image"></p>
<p><strong>重要：</strong> 虽然 <code>libuv</code> 的异步文件 <code>I/O</code>操作是通过线程池实现的，但是网络 <code>I/O</code> 总是在单线程中执行的。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_loop">事件循环Event loop</a></li>
<li><a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">WHATWG规范对Event loop</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">并发模型与事件循环</a></li>
<li><a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">任务，微任务，队列和日程安排</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/"><code>The Node.js Event Loop, Timers, and process.nextTick()</code></a></li>
<li><a target="_blank" rel="noopener" href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882">不要混淆nodejs和浏览器中的event loop</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/libuv/libuv">跨平台异步I&#x2F;O. libuv</a></li>
<li><a target="_blank" rel="noopener" href="http://acemood.github.io/2016/02/01/event-loop-in-javascript/">Event loop in JavaScript</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-v8engine/">使用 Google V8 引擎开发可定制的应用程序</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/yjhjstz/deep-into-node">深入理解Nodejs核心思想与源码分析基于node v6.0.0</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xtx1130/blog">node源码粗读系列文章</a></li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/process.html#process_process_nexttick_callback_args">process.nextTick(callback[, …args])</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.libuv.org/en/v1.x/design.html">libuv 设计概述</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/latentflip/loupe">在运行时可视化<code>javascript</code>运行时</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/08/17/%E6%89%BF%E8%AF%BAPromises/" rel="prev" title="承诺Promises">
      <i class="fa fa-chevron-left"></i> 承诺Promises
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/11/27/rn%E8%93%9D%E7%89%99%E6%89%93%E5%8D%B0/" rel="next" title="rn蓝牙打印">
      rn蓝牙打印 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.</span> <span class="nav-text">事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#V8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.</span> <span class="nav-text">V8引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#handle"><span class="nav-number">1.1.1.</span> <span class="nav-text">handle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87-context"><span class="nav-number">1.1.2.</span> <span class="nav-text">上下文(context)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">运行时概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">可视化描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.2.2.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.2.3.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.2.4.</span> <span class="nav-text">队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.</span> <span class="nav-text">浏览器事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-WHATWG%E8%A7%84%E8%8C%83"><span class="nav-number">2.1.</span> <span class="nav-text">事件循环(WHATWG规范)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">事件循环机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">事件循环处理模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1-microtask"><span class="nav-number">2.4.</span> <span class="nav-text">微任务(microtask)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1-macrotask"><span class="nav-number">2.5.</span> <span class="nav-text">宏任务(macrotask)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-number">2.6.</span> <span class="nav-text">测试代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nodejs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.</span> <span class="nav-text">nodejs事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1"><span class="nav-number">3.1.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">事件循环操作顺序:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E6%A6%82%E8%BF%B0"><span class="nav-number">3.3.</span> <span class="nav-text">阶段概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%B6%E6%AE%B5%E8%AF%A6%E6%83%85"><span class="nav-number">3.4.</span> <span class="nav-text">循环阶段详情</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8-timers"><span class="nav-number">3.4.1.</span> <span class="nav-text">计时器(timers)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%9B%9E%E8%B0%83-pending-callbacks"><span class="nav-number">3.4.2.</span> <span class="nav-text">等待回调(pending callbacks)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2-poll"><span class="nav-number">3.4.3.</span> <span class="nav-text">轮询(poll)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check"><span class="nav-number">3.4.4.</span> <span class="nav-text">check</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E5%9B%9E%E8%B0%83close-callbacks"><span class="nav-number">3.4.5.</span> <span class="nav-text">关闭回调close callbacks</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setImmediate-%E4%B8%8E-setTimeout"><span class="nav-number">3.5.</span> <span class="nav-text">setImmediate() 与 setTimeout()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process-nextTick"><span class="nav-number">3.6.</span> <span class="nav-text">process.nextTick()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3process-nextTick"><span class="nav-number">3.6.1.</span> <span class="nav-text">了解process.nextTick()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A2%AB%E5%85%81%E8%AE%B8"><span class="nav-number">3.6.2.</span> <span class="nav-text">为什么会被允许</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process-nextTick-vs-setImmediate"><span class="nav-number">3.7.</span> <span class="nav-text">process.nextTick() vs setImmediate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8process-nextTick"><span class="nav-number">3.8.</span> <span class="nav-text">为什么使用process.nextTick()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libuv"><span class="nav-number">4.</span> <span class="nav-text">libuv</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-x2F-O-%E6%88%96%E4%BA%8B%E4%BB%B6-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.1.</span> <span class="nav-text">I&#x2F;O(或事件)循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="nav-number">5.</span> <span class="nav-text">相关链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">某人</p>
  <div class="site-description" itemprop="description">此前素未谋面、此后遥遥无期</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">某人</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
